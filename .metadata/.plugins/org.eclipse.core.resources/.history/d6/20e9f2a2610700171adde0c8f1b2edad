/* Generated By:JavaCC: Do not edit this line. RubyParser14.java */
import java.io.StringReader;
import java.io.InputStream;
import java.io.Reader;

public class RubyParser14 implements RubyParser14Constants {

        private static InputStream input;

        private static boolean inputFromFile = false;

        private static String file = "code.rb";

        private class Metrics {
                private final static int AMOUNT_OF_METRICS = 23;
                public long metrics[] = new long[AMOUNT_OF_METRICS];
        }

        /*  
	 * A String based constructor for ease of use
	 */
        public RubyParser14(String s) {
                this((Reader)(new StringReader(s)));
        }

        public static void main(String args[]) {
                try {
                        //String inputProgram = args[0];
                        //String inputProgram = "def bubble_sort(array) n = array.length loop do swapped = false (n-1).times do |i| if array[i] > array[i+1] array[i], array[i+1] = array[i+1], array[i] swapped = true end end break if not swapped end array end";
                        String inputProgram = "puts:==::_abc";

                        /*if (inputFromFile) {
                                System.out.println("Reading from file " + file + " ...");
                                try {
                                        input = new java.io.FileInputStream(file);
                                } catch (java.io.FileNotFoundException e) {
                                        System.out.println("File " + file + " not found.");
                                        return;
                                }
                        } else {
                                System.out.println("Reading from standard input ...");
                                input = System.in;
                        }
                        */
                        RubyParser14 parser = new RubyParser14(inputProgram);
                        parser.CALL();
                        System.out.println("Done!");
                }
                catch(Exception e) {
                        e.printStackTrace();
        }
    }

/*
 * @Production
 * PROGRAM : COMPSTMT
 */
  static final public void PROGRAM() throws ParseException {
    COMPSTMT();
  }

/*
 * @Production
 * COMPSTMT : STMT {T EXPR} [T]
 */
  static final public void COMPSTMT() throws ParseException {
    STMT();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(T);
      EXPR();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T:
      jj_consume_token(T);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
  }

/*
 * @Production
 * STMT 	: CALL do ["|" [BLOCK_VAR] "|"] COMPSTMT end
 *	 		| undef FNAME
 * 			| alias FNAME FNAME
 * 			| STMT if EXPR
 * 			| STMT while EXPR
 * 			| STMT unless EXPR
 * 			| STMT until EXPR
 * 			| "BEGIN" "{" COMPSTMT "}" //object initializer
 * 			| "END" "{" COMPSTMT "}" //object finalizer
 * 			| LHS = COMMAND [do ["|" [BLOCK_VAR] "|"] COMPSTMT end]
 * 			| EXPR
 */

// With left recursion:
//
//void STMT() : 
//{}
//{
//	CALL() <keyword_do> [<pipe> [BLOCK_VAR()] <pipe>] COMPSTMT() <keyword_end>
//	| <keyword_undef> FNAME()
//	| <keyword_alias> FNAME() FNAME()
//	| STMT() <keyword_if> EXPR()
//	| STMT() <keyword_while> EXPR()
//	| STMT() <keyword_unless> EXPR()
//	| STMT() <keyword_until> EXPR()
//	| <keyword_BEGIN> <lbrace> COMPSTMT() <rbrace> //object initializer
//	| <keyword_END> <lbrace> COMPSTMT() <rbrace> //object finalizer
//	| LHS() <equal> COMMAND() [<keyword_do> [<pipe> [BLOCK_VAR()] <pipe>] COMPSTMT() <keyword_end>]
//	| EXPR()
//}
  static final public void STMT() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      CALL();
      jj_consume_token(keyword_do);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pipe:
        jj_consume_token(pipe);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case lshift:
        case star:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          BLOCK_VAR();
          break;
        default:
          jj_la1[2] = jj_gen;
          ;
        }
        jj_consume_token(pipe);
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      COMPSTMT();
      jj_consume_token(keyword_end);
      STMT2();
      break;
    case keyword_undef:
      jj_consume_token(keyword_undef);
      FNAME();
      STMT2();
      break;
    case keyword_alias:
      jj_consume_token(keyword_alias);
      FNAME();
      FNAME();
      STMT2();
      break;
    case keyword_BEGIN:
      jj_consume_token(keyword_BEGIN);
      jj_consume_token(lbrace);
      COMPSTMT();
      jj_consume_token(rbrace);
      STMT2();
      break;
    case keyword_END:
      jj_consume_token(keyword_END);
      jj_consume_token(lbrace);
      COMPSTMT();
      jj_consume_token(rbrace);
      STMT2();
      break;
      case exclamation:
    case tilde:
    case plus:
    case minus:
    case star:
    case keyword_not:
      EXPR();
      STMT2();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void STMT2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case keyword_if:
      jj_consume_token(keyword_if);
      EXPR();
      STMT2();
      break;
    case keyword_while:
      jj_consume_token(keyword_while);
      EXPR();
      STMT2();
      break;
    case keyword_unless:
      jj_consume_token(keyword_unless);
      EXPR();
      STMT2();
      break;
    case keyword_until:
      jj_consume_token(keyword_until);
      EXPR();
      STMT2();
      break;
    case eps:
      jj_consume_token(eps);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * Any char
 */
  static final public void any_character() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
      jj_consume_token(letter);
      break;
    case digit:
      jj_consume_token(digit);
      break;
    case symbol:
      jj_consume_token(symbol);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * Char
 */
  static final public void character() throws ParseException {
    jj_consume_token(letter);
  }

/*
 * @Production
 * EXPR		: MLHS = MRHS
 * 			| return CALL_ARGS
 * 			| yield CALL_ARGS
 * 			| EXPR and EXPR
 * 			| EXPR or EXPR
 * 			| not EXPR
 * 			| COMMAND
 * 			| ! COMMAND
 * 			| ARG
 */
// With left recursion:
//
//void EXPR() : 
//{}
//{
//	MLHS() <equal> MRHS()
//	| <keyword_return> CALL_ARGS()
//	| <keyword_yield> CALL_ARGS()
//	| EXPR() <keyword_or> EXPR()
//	| EXPR() <keyword_or> EXPR()
//	| <keyword_not> EXPR()
//	| COMMAND()
//	| <exclamation> COMMAND()
//	| ARG()
//}
  static final public void EXPR() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case star:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      MLHS();
      jj_consume_token(equal);
      MRHS();
      EXPR2();
      break;
      case keyword_not:
      jj_consume_token(keyword_not);
      EXPR();
      EXPR2();
      break;
      case exclamation:
      jj_consume_token(exclamation);
      COMMAND();
      EXPR2();
      break;
    case tilde:
    case plus:
    case minus:
      ARG();
      EXPR2();
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void EXPR2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case keyword_or:
      jj_consume_token(keyword_or);
      EXPR();
      EXPR2();
      break;
      case eps:
      jj_consume_token(eps);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * CALL : FUNCTION
 * 		| COMMAN
 */
  static final public void CALL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      FUNCTION();
      break;
      default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * COMMAND 	: OPERATION CALL_ARGS
 * 			| PRIMARY . OPERATION CALL_ARGS
 * 			| PRIMARY :: OPERATION CALL_ARGS
 * 			| super CALL_ARGS
 */
  static final public void COMMAND() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case letter:
      OPERATION();
      CALL_ARGS();
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      PRIMARY();
      jj_consume_token(dot);
      OPERATION();
      CALL_ARGS();
      break;
      default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * FUNCTION 	: OPERATION ["(" [CALL_ARGS] ")"]
 * 				| PRIMARY . OPERATION "(" [CALL_ARGS] ")"
 * 				| PRIMARY :: OPERATION "(" [CALL_ARGS] ")"
 * 				| PRIMARY . OPERATION
 * 				| PRIMARY :: OPERATION
 * 				| super "(" [CALL_ARGS] ")"
 * 				| super
 */
// With left recursion:
//
//void FUNCTION() : 
//{}
//{
//	OPERATION() [<lparen> [CALL_ARGS()] <rparen>]
//	| PRIMARY() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen>
//	| PRIMARY() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen>
//	| PRIMARY() <dot> OPERATION()
//	| PRIMARY() <colon2> OPERATION()
//	| <keyword_super> <lparen> [CALL_ARGS()] <rparen>
//	| <keyword_super>
//}

//void FUNCTION() : 
//{}
//{
//	OPERATION() [<lparen> [CALL_ARGS()] <rparen>] FUNCTION2()
//	| <keyword_super> <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_super> FUNCTION2()
//}
//
//void FUNCTION2() : 
//{}
//{
//	<dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <dot> OPERATION() FUNCTION2()
//	| <colon2> OPERATION() FUNCTION2()
//	| <eps>
//}

//void FUNCTION() : 
//{}
//{
//	OPERATION() [<lparen> [CALL_ARGS()] <rparen>] FUNCTION2()
////1
//    | <lparen> COMPSTMT() <rparen> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| LITERAL() PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| VARIABLE() PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <colon2> IDENTIFIER() PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <lsqbracket> [ARGS()[<comma>]] <rsqbracket> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <lbrace> [PRIMARY3() [<comma>]] <rbrace> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_return> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_yield> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_defined> <lparen> ARG() <rparen> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_if> EXPR() THEN() COMPSTMT() (<keyword_elsif> EXPR() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_unless> EXPR() THEN() COMPSTMT() [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_while> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_until> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_case> COMPSTMT() <keyword_when> WHEN_ARGS() THEN() COMPSTMT() (<keyword_when> WHEN_ARGS() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_for> BLOCK_VAR() <keyword_in> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_begin> COMPSTMT() (<keyword_rescue> [ARGS()] DO() COMPSTMT())* [<keyword_else> COMPSTMT()] [<keyword_ensure> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_class> IDENTIFIER() [<less> IDENTIFIER()] COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_module> IDENTIFIER() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_def> FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_def> SINGLETON() (<dot> | <colon2>) FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
////2
//	| <lparen> COMPSTMT() <rparen> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| LITERAL() PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| VARIABLE() PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <colon2> IDENTIFIER() PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <lsqbracket> [ARGS()[<comma>]] <rsqbracket> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <lbrace> [PRIMARY3() [<comma>]] <rbrace> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_return> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_yield> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_defined> <lparen> ARG() <rparen> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_if> EXPR() THEN() COMPSTMT() (<keyword_elsif> EXPR() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_unless> EXPR() THEN() COMPSTMT() [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_while> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_until> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_case> COMPSTMT() <keyword_when> WHEN_ARGS() THEN() COMPSTMT() (<keyword_when> WHEN_ARGS() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_for> BLOCK_VAR() <keyword_in> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_begin> COMPSTMT() (<keyword_rescue> [ARGS()] DO() COMPSTMT())* [<keyword_else> COMPSTMT()] [<keyword_ensure> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_class> IDENTIFIER() [<less> IDENTIFIER()] COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_module> IDENTIFIER() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_def> FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_def> SINGLETON() (<dot> | <colon2>) FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
////3
//	| <lparen> COMPSTMT() <rparen> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| LITERAL() PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| VARIABLE() PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <colon2> IDENTIFIER() PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <lsqbracket> [ARGS()[<comma>]] <rsqbracket> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <lbrace> [PRIMARY3() [<comma>]] <rbrace> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_return> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_yield> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_defined> <lparen> ARG() <rparen> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_if> EXPR() THEN() COMPSTMT() (<keyword_elsif> EXPR() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_unless> EXPR() THEN() COMPSTMT() [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_while> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_until> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_case> COMPSTMT() <keyword_when> WHEN_ARGS() THEN() COMPSTMT() (<keyword_when> WHEN_ARGS() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_for> BLOCK_VAR() <keyword_in> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_begin> COMPSTMT() (<keyword_rescue> [ARGS()] DO() COMPSTMT())* [<keyword_else> COMPSTMT()] [<keyword_ensure> COMPSTMT()] <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_class> IDENTIFIER() [<less> IDENTIFIER()] COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_module> IDENTIFIER() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_def> FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
//	| <keyword_def> SINGLETON() (<dot> | <colon2>) FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <dot> OPERATION() FUNCTION2()
////4
//	| <lparen> COMPSTMT() <rparen> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| LITERAL() PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| VARIABLE() PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <colon2> IDENTIFIER() PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <lsqbracket> [ARGS()[<comma>]] <rsqbracket> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <lbrace> [PRIMARY3() [<comma>]] <rbrace> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_return> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_yield> [<lparen> [CALL_ARGS()] <rparen>] PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_defined> <lparen> ARG() <rparen> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_if> EXPR() THEN() COMPSTMT() (<keyword_elsif> EXPR() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_unless> EXPR() THEN() COMPSTMT() [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_while> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_until> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_case> COMPSTMT() <keyword_when> WHEN_ARGS() THEN() COMPSTMT() (<keyword_when> WHEN_ARGS() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_for> BLOCK_VAR() <keyword_in> EXPR() DO() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_begin> COMPSTMT() (<keyword_rescue> [ARGS()] DO() COMPSTMT())* [<keyword_else> COMPSTMT()] [<keyword_ensure> COMPSTMT()] <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_class> IDENTIFIER() [<less> IDENTIFIER()] COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_module> IDENTIFIER() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_def> FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
//	| <keyword_def> SINGLETON() (<dot> | <colon2>) FNAME() ARGDECL() COMPSTMT() <keyword_end> PRIMARY2() <colon2> OPERATION() FUNCTION2()
////Other
//	| <keyword_super> <lparen> [CALL_ARGS()] <rparen> FUNCTION2()
//	| <keyword_super> FUNCTION2()
//}
  static final public void FUNCTION() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case letter:
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      FUNCTION2();
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
      FUNCTION3();
      jj_consume_token(dot);
      OPERATION();
      jj_consume_token(lparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case star:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        CALL_ARGS();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      jj_consume_token(rparen);
      FUNCTION2();
      break;
      case keyword_super:
      jj_consume_token(keyword_super);
      jj_consume_token(lparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case star:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        CALL_ARGS();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      jj_consume_token(rparen);
      FUNCTION2();
      break;
      default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void FUNCTION2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      FUNCTION();
      PRIMARY2();
      jj_consume_token(dot);
      OPERATION();
      jj_consume_token(lparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case star:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        CALL_ARGS();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      jj_consume_token(rparen);
      FUNCTION2();
      break;
      case eps:
      jj_consume_token(eps);
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void FUNCTION3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lparen:
      jj_consume_token(lparen);
      COMPSTMT();
      jj_consume_token(rparen);
      PRIMARY2();
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lshift:
    case slash:
    case percent:
    case keyword_numeric:
      LITERAL();
      PRIMARY2();
      break;
    case underline:
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
    case letter:
      VARIABLE();
      PRIMARY2();
      jj_consume_token(dot);
      OPERATION();
      jj_consume_token(lparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case star:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        CALL_ARGS();
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      jj_consume_token(rparen);
      FUNCTION2();
      break;
    case colon2:
      jj_consume_token(colon2);
      IDENTIFIER();
      PRIMARY2();
      break;
    case lsqbracket:
      jj_consume_token(lsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        ARGS();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          jj_consume_token(comma);
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(rsqbracket);
      PRIMARY2();
      break;
    case lbrace:
      jj_consume_token(lbrace);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        PRIMARY3();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          jj_consume_token(comma);
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      jj_consume_token(rbrace);
      PRIMARY2();
      break;
    case keyword_return:
      jj_consume_token(keyword_return);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[38] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      PRIMARY2();
      break;
    case keyword_yield:
      jj_consume_token(keyword_yield);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[40] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      PRIMARY2();
      break;
    case keyword_defined:
      jj_consume_token(keyword_defined);
      jj_consume_token(lparen);
      ARG();
      jj_consume_token(rparen);
      PRIMARY2();
      break;
    case keyword_if:
      jj_consume_token(keyword_if);
      EXPR();
      THEN();
      COMPSTMT();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_elsif:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_2;
        }
        jj_consume_token(keyword_elsif);
        EXPR();
        THEN();
        COMPSTMT();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_unless:
      jj_consume_token(keyword_unless);
      EXPR();
      THEN();
      COMPSTMT();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_while:
      jj_consume_token(keyword_while);
      EXPR();
      DO();
      COMPSTMT();
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_until:
      jj_consume_token(keyword_until);
      EXPR();
      DO();
      COMPSTMT();
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_case:
      jj_consume_token(keyword_case);
      COMPSTMT();
      jj_consume_token(keyword_when);
      WHEN_ARGS();
      THEN();
      COMPSTMT();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_when:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_3;
        }
        jj_consume_token(keyword_when);
        WHEN_ARGS();
        THEN();
        COMPSTMT();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_for:
      jj_consume_token(keyword_for);
      BLOCK_VAR();
      jj_consume_token(keyword_in);
      EXPR();
      DO();
      COMPSTMT();
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_begin:
      jj_consume_token(keyword_begin);
      COMPSTMT();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_rescue:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_4;
        }
        jj_consume_token(keyword_rescue);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          ARGS();
          break;
        default:
          jj_la1[48] = jj_gen;
          ;
        }
        DO();
        COMPSTMT();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_ensure:
        jj_consume_token(keyword_ensure);
        COMPSTMT();
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_class:
      jj_consume_token(keyword_class);
      IDENTIFIER();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case less:
        jj_consume_token(less);
        IDENTIFIER();
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      COMPSTMT();
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_module:
      jj_consume_token(keyword_module);
      IDENTIFIER();
      COMPSTMT();
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
    case keyword_def:
      jj_consume_token(keyword_def);
      FNAME();
      ARGDECL();
      COMPSTMT();
      jj_consume_token(keyword_end);
      PRIMARY2();
      break;
      default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * ARG 	: LHS = ARG
 * 		| LHS OP_ASGN ARG
 * 		| ARG .. ARG
 * 		| ARG ... ARG
 * 		| ARG + ARG
 * 		| ARG - ARG
 * 		| ARG * ARG
 * 		| ARG / ARG
 * 		| ARG % ARG
 * 		| ARG ** ARG
 * 		| + ARG
 * 		| - ARG
 * 		| ARG "|" ARG
 * 		| ARG ^ ARG
 * 		| ARG & ARG
 * 		| ARG <=> ARG
 * 		| ARG > ARG
 * 		| ARG >= ARG
 * 		| ARG < ARG
 * 		| ARG <= ARG
 * 		| ARG == ARG
 * 		| ARG === ARG
 * 		| ARG != ARG
 * 		| ARG =~ ARG
 * 		| ARG !~ ARG
 * 		| ! ARG
 * 		| ~ ARG
 * 		| ARG << ARG
 * 		| ARG >> ARG
 * 		| ARG && ARG
 * 		| ARG || ARG
 * 		| defined? ARG
 * 		| PRIMARY
 */
// With left recursion:
//
//void ARG() : 
//{}
//{
//	LHS() <equal> ARG()
//	| LHS() OP_ASGN() ARG()
//	| ARG() <dot2> ARG()
//	| ARG() <dot3> ARG()
//	| ARG() <plus> ARG()
//	| ARG() <minus> ARG()
//	| ARG() <star> ARG()
//	| ARG() <slash> ARG()
//	| ARG() <percent> ARG()
//	| ARG() <power> ARG()
//	| <plus> ARG()
//	| <minus> ARG()
//	| ARG() <pipe> ARG()
//	| ARG() <caret> ARG()
//	| ARG() <amper> ARG()
//	| ARG() <lessequalmore> ARG()
//	| ARG() <more> ARG()
//	| ARG() <moreorequal> ARG()
//	| ARG() <less> ARG()
//	| ARG() <lessorequal> ARG()
//	| ARG() <equal2> ARG()
//	| ARG() <equal3> ARG()
//	| ARG() <exclamationequal> ARG()
//	| ARG() <equaltilde> ARG()
//	| ARG() <exclamationtilde> ARG()
//	| <exclamation> ARG()
//	| <tilde> ARG()
//	| ARG() <lshift> ARG()
//	| ARG() <rshift> ARG()
//	| ARG() <and> ARG()
//	| ARG() <or> ARG()
//	| <keyword_defined> ARG()
//	| PRIMARY()
//}
  static final public void ARG() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      LHS();
      jj_consume_token(equal);
      ARG();
      ARG2();
      break;
      case plus:
      jj_consume_token(plus);
      ARG();
      ARG2();
      break;
    case minus:
      jj_consume_token(minus);
      ARG();
      ARG2();
      break;
    case exclamation:
      jj_consume_token(exclamation);
      ARG();
      ARG2();
      break;
    case tilde:
      jj_consume_token(tilde);
      ARG();
      ARG2();
      break;
      default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void ARG2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case dot2:
      jj_consume_token(dot2);
      ARG();
      ARG2();
      break;
    case dot3:
      jj_consume_token(dot3);
      ARG();
      ARG2();
      break;
    case plus:
      jj_consume_token(plus);
      ARG();
      ARG2();
      break;
    case minus:
      jj_consume_token(minus);
      ARG();
      ARG2();
      break;
    case star:
      jj_consume_token(star);
      ARG();
      ARG2();
      break;
    case slash:
      jj_consume_token(slash);
      ARG();
      ARG2();
      break;
    case percent:
      jj_consume_token(percent);
      ARG();
      ARG2();
      break;
    case power:
      jj_consume_token(power);
      ARG();
      ARG2();
      break;
    case pipe:
      jj_consume_token(pipe);
      ARG();
      ARG2();
      break;
    case caret:
      jj_consume_token(caret);
      ARG();
      ARG2();
      break;
    case amper:
      jj_consume_token(amper);
      ARG();
      ARG2();
      break;
    case lessequalmore:
      jj_consume_token(lessequalmore);
      ARG();
      ARG2();
      break;
    case more:
      jj_consume_token(more);
      ARG();
      ARG2();
      break;
    case moreorequal:
      jj_consume_token(moreorequal);
      ARG();
      ARG2();
      break;
    case less:
      jj_consume_token(less);
      ARG();
      ARG2();
      break;
    case lessorequal:
      jj_consume_token(lessorequal);
      ARG();
      ARG2();
      break;
    case equal2:
      jj_consume_token(equal2);
      ARG();
      ARG2();
      break;
    case equal3:
      jj_consume_token(equal3);
      ARG();
      ARG2();
      break;
    case exclamationequal:
      jj_consume_token(exclamationequal);
      ARG();
      ARG2();
      break;
    case equaltilde:
      jj_consume_token(equaltilde);
      ARG();
      ARG2();
      break;
    case exclamationtilde:
      jj_consume_token(exclamationtilde);
      ARG();
      ARG2();
      break;
    case lshift:
      jj_consume_token(lshift);
      ARG();
      ARG2();
      break;
    case rshift:
      jj_consume_token(rshift);
      ARG();
      ARG2();
      break;
    case and:
      jj_consume_token(and);
      ARG();
      ARG2();
      break;
    case or:
      jj_consume_token(or);
      ARG();
      ARG2();
      break;
    case eps:
      jj_consume_token(eps);
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * PRIMARY	: "(" COMPSTMT ")"
 * 			| LITERAL
 * 			| VARIABLE
 * 			| PRIMARY :: IDENTIFIER
 * 			| :: IDENTIFIER
 * 			| PRIMARY "[" [ARGS] "]"
 * 			| "[" [ARGS[,]] "]"
 * 			| "{" [ARGS
 * 			| ASSOCS [,]] "}"
 * 			| return ["(" [CALL_ARGS] ")"]
 * 			| yield ["(" [CALL_ARGS] ")"]
 * 			| defined? "(" ARG ")"
 * 			| FUNCTION
 * 			| FUNCTION "{" ["|" [BLOCK_VAR] "|"] COMPSTMT "}"
 * 			| if EXPR THEN COMPSTMT {elsif EXPR THEN COMPSTMT} [else COMPSTMT] end
 * 			| unless EXPR THEN COMPSTMT [else COMPSTMT] end
 * 			| while EXPR DO COMPSTMT end
 * 			| until EXPR DO COMPSTMT end
 * 			| case COMPSTMT when WHEN_ARGS THEN COMPSTMT {when WHEN_ARGS THEN COMPSTMT} [else COMPSTMT] end
 * 			| for BLOCK_VAR in EXPR DO COMPSTMT end
 * 			| begin COMPSTMT {rescue [ARGS] DO COMPSTMT} [else COMPSTMT] [ensure COMPSTMT] end
 * 			| class IDENTIFIER [< IDENTIFIER] COMPSTMT end
 * 			| module IDENTIFIER COMPSTMT end
 * 			| def FNAME ARGDECL COMPSTMT end
 * 			| def SINGLETON (. | ::) FNAME ARGDECL COMPSTMT end
 */
// With left recursion:
//
//void PRIMARY() : 
//{}
//{
//	<lparen> COMPSTMT() <rparen>
//	| LITERAL()
//	| VARIABLE()
//	| PRIMARY() <colon2> IDENTIFIER()
//	| <colon2> IDENTIFIER()
//	| PRIMARY() <lsqbracket> [ARGS()] <rsqbracket>
//	| <lsqbracket> [ARGS()[<comma>]] <rsqbracket>
//	| <lbrace> [ARGS() | ASSOCS() [<comma>]] <rbrace>
//	| <keyword_return> [<lparen> [CALL_ARGS()] <rparen>]
//	| <keyword_yield> [<lparen> [CALL_ARGS()] <rparen>]
//	| <keyword_defined> <lparen> ARG() <rparen>
//	| FUNCTION()
//	| FUNCTION() <lbrace> [<pipe> [BLOCK_VAR()] <pipe>] COMPSTMT() <rbrace>
//	| <keyword_if> EXPR() THEN() COMPSTMT() (<keyword_elsif> EXPR() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end>
//	| <keyword_unless> EXPR() THEN() COMPSTMT() [<keyword_else> COMPSTMT()] <keyword_end>
//	| <keyword_while> EXPR() DO() COMPSTMT() <keyword_end>
//	| <keyword_until> EXPR() DO() COMPSTMT() <keyword_end>
//	| <keyword_case> COMPSTMT() <keyword_when> WHEN_ARGS() THEN() COMPSTMT() (<keyword_when> WHEN_ARGS() THEN() COMPSTMT())* [<keyword_else> COMPSTMT()] <keyword_end>
//	| <keyword_for> BLOCK_VAR() <keyword_in> EXPR() DO() COMPSTMT() <keyword_end>
//	| <keyword_begin> COMPSTMT() (<keyword_rescue> [ARGS()] DO() COMPSTMT())* [<keyword_else> COMPSTMT()] [<keyword_ensure> COMPSTMT()] <keyword_end>
//	| <keyword_class> IDENTIFIER() [<less> IDENTIFIER()] COMPSTMT() <keyword_end>
//	| <keyword_module> IDENTIFIER() COMPSTMT() <keyword_end>
//	| <keyword_def> FNAME() ARGDECL() COMPSTMT() <keyword_end>
//	| <keyword_def> SINGLETON() (<dot> | <colon2>) FNAME() ARGDECL() COMPSTMT() <keyword_end>
//}
  static final public void PRIMARY() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lparen:
      jj_consume_token(lparen);
      COMPSTMT();
      jj_consume_token(rparen);
      PRIMARY2();
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lshift:
    case slash:
    case percent:
    case keyword_numeric:
      LITERAL();
      PRIMARY2();
      break;
    case underline:
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
    case letter:
      VARIABLE();
      PRIMARY2();
      break;
    case colon2:
      jj_consume_token(colon2);
      IDENTIFIER();
      PRIMARY2();
      break;
    case lsqbracket:
      jj_consume_token(lsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        ARGS();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          jj_consume_token(comma);
          break;
        default:
          jj_la1[56] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      jj_consume_token(rsqbracket);
      PRIMARY2();
      break;
    case lbrace:
      jj_consume_token(lbrace);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        PRIMARY3();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          jj_consume_token(comma);
          break;
        default:
          jj_la1[58] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      jj_consume_token(rbrace);
      PRIMARY2();
      break;
    case keyword_return:
      jj_consume_token(keyword_return);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[60] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
      PRIMARY2();
      break;
    case keyword_yield:
      jj_consume_token(keyword_yield);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[62] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
      PRIMARY2();
      break;
    case keyword_defined:
      jj_consume_token(keyword_defined);
      jj_consume_token(lparen);
      ARG();
      jj_consume_token(rparen);
      PRIMARY2();
      break;
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_super:
      FUNCTION();
      PRIMARY2();
      break;
      default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void PRIMARY3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case plus:
    case minus:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      ARGS();
      break;
      default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void PRIMARY2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case colon2:
      jj_consume_token(colon2);
      IDENTIFIER();
      break;
    case lsqbracket:
      jj_consume_token(lsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        ARGS();
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      jj_consume_token(rsqbracket);
      break;
    case eps:
      jj_consume_token(eps);
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * WHEN_ARGS : ARGS [, * ARG] |  * ARG
 */
  static final public void WHEN_ARGS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case plus:
    case minus:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      ARGS();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(star);
        ARG();
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      ARG();
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * THEN 	: T | then | T then //"then" and "do" can go on next line
 */
  static final public void THEN() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T:
      jj_consume_token(T);
      break;
    case keyword_then:
      jj_consume_token(keyword_then);
      break;
      default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * DO 	: T | do | T do
 */
  static final public void DO() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T:
      jj_consume_token(T);
      break;
    case keyword_do:
      jj_consume_token(keyword_do);
      break;
      default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * BLOCK_VAR : LHS | MLHS
 */
  static final public void BLOCK_VAR() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      LHS();
      break;
    case star:
      MLHS();
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * MLHS 	: MLHS_ITEM , [MLHS_ITEM (, MLHS_ITEM)*] [* [LHS]]
 * 			| * LHS
 */
  static final public void MLHS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      MLHS_ITEM();
      jj_consume_token(comma);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case lshift:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        MLHS_ITEM();
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case comma:
            ;
            break;
          default:
            jj_la1[86] = jj_gen;
            break label_8;
          }
          jj_consume_token(comma);
          MLHS_ITEM();
        }
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case star:
        jj_consume_token(star);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underline:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case lshift:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case letter:
        case keyword_super:
          LHS();
          break;
        default:
          jj_la1[88] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      LHS();
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * MLHS_ITEM : LHS | "(" MLHS ")"
 */
  static final public void MLHS_ITEM() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      LHS();
      break;
      default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * LHS 	: VARIABLE
 * 		| PRIMARY "[" [ARGS] "]"
 * 		| PRIMARY.IDENTIFIE
 */
  static final public void LHS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
    case letter:
      VARIABLE();
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lbrace:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_return:
    case keyword_super:
      PRIMARY();
      jj_consume_token(lsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underline:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case letter:
      case keyword_super:
        ARGS();
        break;
      default:
        jj_la1[92] = jj_gen;
        ;
      }
      jj_consume_token(rsqbracket);
      break;
      default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * MRHS 	: ARGS [, * ARG] |  * ARG
 */
  static final public void MRHS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case plus:
    case minus:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      ARGS();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(star);
        ARG();
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      ARG();
      break;
    default:
      jj_la1[95] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * CALL_ARGS 	: ARGS
 * 				| ARGS [, ASSOCS] [, * ARG] [, & ARG]
 * 				| ASSOCS [, * ARG] [, & ARG]
 * 				| * ARG [, & ARG]
 * 				|  & ARG
 * 				| COMMAND
 */
  static final public void CALL_ARGS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underline:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case plus:
    case minus:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case letter:
    case keyword_super:
      ARGS();
      break;
      case star:
      jj_consume_token(star);
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(amper);
        ARG();
        break;
      default:
        jj_la1[101] = jj_gen;
        ;
      }
      break;
    case amper:
      jj_consume_token(amper);
      ARG();
      break;
      default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * ARGS 	: ARG (, ARG)*
 */
  static final public void ARGS() throws ParseException {
    ARG();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        ;
        break;
      default:
        jj_la1[103] = jj_gen;
        break label_9;
      }
      jj_consume_token(comma);
      ARG();
    }
  }

/*
 * @Production
 * ARGDECL	: "(" ARGLIST ")"
 * 		| ARGLIST T
 */
  static final public void ARGDECL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lparen:
      jj_consume_token(lparen);
      ARGLIST();
      jj_consume_token(rparen);
      break;
    case T:
    case underline:
    case star:
    case amper:
    case letter:
      ARGLIST();
      jj_consume_token(T);
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * ARGLIST	: IDENTIFIER(,IDENTIFIER)*[, *[IDENTIFIER]][,&IDENTIFIER]
 * 			| *IDENTIFIER[, &IDENTIFIER]
 * 			| [&IDENTIFIER]
 */
  static final public void ARGLIST() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case letter:
      IDENTIFIER();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          ;
          break;
        default:
          jj_la1[105] = jj_gen;
          break label_10;
        }
        jj_consume_token(comma);
        IDENTIFIER();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(star);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case underline:
        case letter:
          IDENTIFIER();
          break;
        default:
          jj_la1[106] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[107] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(amper);
        IDENTIFIER();
        break;
      default:
        jj_la1[108] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      IDENTIFIER();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(amper);
        IDENTIFIER();
        break;
      default:
        jj_la1[109] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[111] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case amper:
        jj_consume_token(amper);
        IDENTIFIER();
        break;
      default:
        jj_la1[110] = jj_gen;
        ;
      }
    }
  }

/*
 * @Production
 * SINGLETON 	: VARIABLE
 * 				| "(" EXPR ")"
 */
  static final public void SINGLETON() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
    case letter:
      VARIABLE();
      break;
    case lparen:
      jj_consume_token(lparen);
      EXPR();
      jj_consume_token(rparen);
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * ASSOCS : ASSOC {, ASSOC}
 */
  static final public void ASSOCS() throws ParseException {
    ASSOC();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        ;
        break;
      default:
        jj_la1[113] = jj_gen;
        break label_11;
      }
      jj_consume_token(comma);
      ASSOC();
    }
  }

/*
 * @Production
 * ASSOC	: ARG => ARG
 */
  static final public void ASSOC() throws ParseException {
    ARG();
    jj_consume_token(equalmore);
    ARG();
  }

/*
 * @Production
 * VARIABLE	: VARNAME | nil | self
 */
  static final public void VARIABLE() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case at:
    case dollar:
    case letter:
      VARNAME();
      break;
    case keyword_nil:
      jj_consume_token(keyword_nil);
      break;
    case keyword_self:
      jj_consume_token(keyword_self);
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * LITERAL	: numeric | SYMBOL | STRING | STRING2 | HERE_DOC | REGEXP
 */
  static final public void LITERAL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case keyword_numeric:
      jj_consume_token(keyword_numeric);
      break;
    case colon:
      SYMBOL();
      break;
    case quote:
    case apostr:
    case backapostr:
      STRING();
      break;
    case percent:
      STRING2();
      break;
    case lshift:
      HERE_DOC();
      break;
    case slash:
      REGEXP();
      break;
    default:
      jj_la1[115] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// The following are recognized by the lexical analyzer.

/*
 * @Production
 * OP_ASGN	: += | -= | *= | /= | %= | **=
 * 		| &= | |= | ^= | <<= | >>=
 * 		| &&= | ||=
 */
  static final public void OP_ASGN() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case plusequal:
      jj_consume_token(plusequal);
      break;
    case minusequal:
      jj_consume_token(minusequal);
      break;
    case starequal:
      jj_consume_token(starequal);
      break;
    case slashequal:
      jj_consume_token(slashequal);
      break;
    case percentequal:
      jj_consume_token(percentequal);
      break;
    case powerequal:
      jj_consume_token(powerequal);
      break;
    case amperequal:
      jj_consume_token(amperequal);
      break;
    case pipeequal:
      jj_consume_token(pipeequal);
      break;
    case caretequal:
      jj_consume_token(caretequal);
      break;
    case lshiftequal:
      jj_consume_token(lshiftequal);
      break;
    case rshiftequal:
      jj_consume_token(rshiftequal);
      break;
    case andequal:
      jj_consume_token(andequal);
      break;
    case orequal:
      jj_consume_token(orequal);
      break;
    default:
      jj_la1[116] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * SYMBOL	: :FNAME | :VARNAME
 */
  static final public void SYMBOL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case colon:
      jj_consume_token(colon);
      FNAME();
      break;
      default:
      jj_la1[117] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * FNAME	: IDENTIFIER | .. | "|" | ^ | & | <=> | == | === | =~
 * 		| > | >= | < | <= | + | - | * | / | % | **
 * 		| << | >> |  ̃ | +@ | -@ | [] | []=
 */
  static final public void FNAME() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case letter:
      IDENTIFIER();
      break;
    case dot2:
      jj_consume_token(dot2);
      break;
    case pipe:
      jj_consume_token(pipe);
      break;
    case caret:
      jj_consume_token(caret);
      break;
    case amper:
      jj_consume_token(amper);
      break;
    case lessequalmore:
      jj_consume_token(lessequalmore);
      break;
    case equal2:
      jj_consume_token(equal2);
      break;
    case equal3:
      jj_consume_token(equal3);
      break;
    case equaltilde:
      jj_consume_token(equaltilde);
      break;
    case more:
      jj_consume_token(more);
      break;
    case moreorequal:
      jj_consume_token(moreorequal);
      break;
    case less:
      jj_consume_token(less);
      break;
    case lessorequal:
      jj_consume_token(lessorequal);
      break;
    case plus:
      jj_consume_token(plus);
      break;
    case minus:
      jj_consume_token(minus);
      break;
    case star:
      jj_consume_token(star);
      break;
    case slash:
      jj_consume_token(slash);
      break;
    case percent:
      jj_consume_token(percent);
      break;
    case power:
      jj_consume_token(power);
      break;
    case lshift:
      jj_consume_token(lshift);
      break;
    case rshift:
      jj_consume_token(rshift);
      break;
    case tilde:
      jj_consume_token(tilde);
      break;
    case plusat:
      jj_consume_token(plusat);
      break;
    case minusat:
      jj_consume_token(minusat);
      break;
    case sqbrackets:
      jj_consume_token(sqbrackets);
      break;
    case sqbracketsequal:
      jj_consume_token(sqbracketsequal);
      break;
    default:
      jj_la1[118] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * OPERATION : IDENTIFIER [! | ?]
 */
  static final public void OPERATION() throws ParseException {
    IDENTIFIER();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case exclamation:
    case question:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case exclamation:
        jj_consume_token(exclamation);
        break;
      case question:
        jj_consume_token(question);
        break;
      default:
        jj_la1[119] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[120] = jj_gen;
      ;
    }
  }

/*
 * @Production
 * VARNAME : GLOBAL | @IDENTIFIER | IDENTIFIE
 */
  static final public void VARNAME() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case dollar:
      GLOBAL();
      break;
    case at:
      jj_consume_token(at);
      IDENTIFIER();
      break;
    case underline:
    case letter:
      IDENTIFIER();
      break;
    default:
      jj_la1[121] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * GLOBAL	: $IDENTIFIER | $any_char | $-any_char
 */
  static final public void GLOBAL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case dollar:
      jj_consume_token(dollar);
      IDENTIFIER();
      break;
      default:
      jj_la1[122] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * STRING 	: " {any_char} "
		| ’ {any_char} ’
		| ‘ {any_char} ‘
 */
  static final public void STRING() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
      jj_consume_token(quote);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case symbol:
          ;
          break;
        default:
          jj_la1[123] = jj_gen;
          break label_12;
        }
        any_character();
      }
      jj_consume_token(quote);
      break;
    case apostr:
      jj_consume_token(apostr);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case symbol:
          ;
          break;
        default:
          jj_la1[124] = jj_gen;
          break label_13;
        }
        any_character();
      }
      jj_consume_token(apostr);
      break;
    case backapostr:
      jj_consume_token(backapostr);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case symbol:
          ;
          break;
        default:
          jj_la1[125] = jj_gen;
          break label_14;
        }
        any_character();
      }
      jj_consume_token(backapostr);
      break;
    default:
      jj_la1[126] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * STRING2	: %(Q|q|x)char {any_char} char
 */
  static final public void STRING2() throws ParseException {
    jj_consume_token(percent);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Q:
      jj_consume_token(Q);
      break;
    case q:
      jj_consume_token(q);
      break;
    case x:
      jj_consume_token(x);
      break;
    default:
      jj_la1[127] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    character();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case digit:
      case symbol:
        ;
        break;
      default:
        jj_la1[128] = jj_gen;
        break label_15;
      }
      any_character();
    }
    character();
  }

/*
 * @Production
 * HERE_DOC : <<(IDENTIFIER | STRING) {any_char} IDENTIFIER
 */
  static final public void HERE_DOC() throws ParseException {
    jj_consume_token(lshift);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case underline:
    case letter:
      IDENTIFIER();
      break;
    case quote:
    case apostr:
    case backapostr:
      STRING();
      break;
    default:
      jj_la1[129] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case digit:
      case symbol:
        ;
        break;
      default:
        jj_la1[130] = jj_gen;
        break label_16;
      }
      any_character();
    }
    IDENTIFIER();
  }

/*
 * @Production
 * REGEXP	: / {any_char} / [i|o|p]
 * 			| %r char {any_char} char
 */
  static final public void REGEXP() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case slash:
      jj_consume_token(slash);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case symbol:
          ;
          break;
        default:
          jj_la1[131] = jj_gen;
          break label_17;
        }
        any_character();
      }
      jj_consume_token(slash);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case i:
      case o:
      case p:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case i:
          jj_consume_token(i);
          break;
        case o:
          jj_consume_token(o);
          break;
        case p:
          jj_consume_token(p);
          break;
        default:
          jj_la1[132] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[133] = jj_gen;
        ;
      }
      break;
    case percent:
      jj_consume_token(percent);
      jj_consume_token(r);
      character();
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case symbol:
          ;
          break;
        default:
          jj_la1[134] = jj_gen;
          break label_18;
        }
        any_character();
      }
      character();
      break;
    default:
      jj_la1[135] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 * @Production
 * IDENTIFIER	: sequence in /[a-zA-Z_]{a-zA-Z0-9_}/.
 */
  static final public void IDENTIFIER() throws ParseException {
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
        jj_consume_token(letter);
        break;
      case underline:
        jj_consume_token(underline);
        break;
      default:
        jj_la1[136] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case underline:
      case letter:
        ;
        break;
      default:
        jj_la1[137] = jj_gen;
        break label_19;
      }
    }
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case underline:
      case letter:
      case digit:
        ;
        break;
      default:
        jj_la1[138] = jj_gen;
        break label_20;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
        jj_consume_token(letter);
        break;
      case underline:
        jj_consume_token(underline);
        break;
      case digit:
        jj_consume_token(digit);
        break;
      default:
        jj_la1[139] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public RubyParser14TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[140];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2,0x2,0x26800178,0x4,0x26800178,0x4,0x0,0x26800178,0x0,0x0,0x26800178,0x0,0x26800178,0x26800178,0x26800178,0x0,0x26800178,0x26800178,0x26800178,0x26800178,0x26800178,0x26800178,0x4,0x26800178,0x26800178,0x26800178,0x4,0x26800178,0x26800178,0x4,0x26800178,0x4,0x26800178,0x26800178,0x0,0x26800178,0x0,0x26800178,0x26800178,0x0,0x26800178,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x26800178,0x0,0x0,0x0,0x0,0x26800178,0x26800178,0x600004,0x0,0x26800178,0x0,0x26800178,0x26800178,0x0,0x26800178,0x0,0x26800178,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x26800178,0x0,0x0,0x0,0x0,0x26800178,0x26800178,0x26800178,0x20000000,0x0,0x26800178,0x2,0x2,0x26800178,0x0,0x26800178,0x26800178,0x0,0x26800178,0x26800178,0x26800178,0x26800178,0x0,0x26800178,0x0,0x0,0x0,0x0,0x0,0x0,0x26800178,0x0,0x102,0x0,0x100,0x0,0x0,0x0,0x0,0x100,0x6000100,0x0,0x6000100,0x78,0x1ffe00,0x40,0xd8600104,0x0,0x0,0x6000100,0x4000000,0x0,0x0,0x0,0x38,0x0,0x0,0x138,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x100,0x100,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x1a000802,0x0,0x1a000802,0x0,0x0,0x1b800a12,0x0,0x0,0x1b800a12,0x0,0x18000802,0x18000802,0x3b800a12,0x2,0x3b800a12,0x3b800a12,0x3b800a12,0x18000802,0x3b800a12,0x1a000802,0x0,0x3b800a12,0x3b800a12,0x1a000802,0x0,0x3b800a12,0x1a000802,0x0,0x1a000802,0x0,0x18000802,0x3b800a12,0x8,0x19800a12,0x8,0x19800a12,0x3b800a12,0x2,0x3b800a12,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x19800a12,0x0,0x0,0x400,0x100000,0x18000802,0x19800a12,0xffeafdc0,0x8,0x19800a12,0x8,0x19800a12,0x3b800a12,0x2,0x3b800a12,0x2,0x1a000802,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x19800a12,0x0,0x0,0x400,0x100000,0x18000802,0x19800a12,0x19800a12,0x0,0x8,0x1b800a12,0x0,0x0,0x1a000802,0x8,0x18000802,0x18000802,0x2000000,0x1a000802,0x18000802,0x19800a12,0x18000802,0x8,0x1b800a12,0x8,0x8,0x8,0x8,0x8,0x8,0x3b800a12,0x8,0x22000002,0x8,0x0,0x8,0x8,0x8,0x20000000,0x2000000,0x2,0x8,0x0,0x18000800,0x10000,0x0,0x3faaff00,0x30,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18000000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x9ee40be5,0x0,0x9ee40be5,0x0,0x2,0x9ee57be5,0x6240000,0x0,0x9ee40be5,0x40000000,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x0,0x100000,0x20000,0x20000,0x1000000,0x20000,0x8000,0x9ee40be5,0x20000,0x10,0x0,0x1,0x9ee40be5,0x9ee40be5,0x0,0x0,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x0,0x9ee40be5,0x0,0x100000,0x20000,0x20000,0x1000000,0x20000,0x8000,0x9ee40be5,0x20000,0x10,0x0,0x1,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x1,0x0,0x9ee40be5,0x8,0x2,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x9ee40be5,0x0,0x9ee40be5,0x0,0x0,0x0,0x0,0x0,0x0,0x9ee40be5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000004,0x0,0x10000004,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x1004,0x0,0x1004,0x0,0x0,0x1005,0x2,0x1c,0x1005,0x2,0x1004,0x1004,0x1004,0x0,0x1004,0x1004,0x1004,0x1004,0x1004,0x1004,0x0,0x1004,0x1004,0x1004,0x0,0x1004,0x1004,0x0,0x1004,0x0,0x1006,0x1004,0x0,0x1004,0x0,0x1004,0x1004,0x0,0x1004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1004,0x0,0x0,0x0,0x0,0x4,0x1004,0x2,0x0,0x1004,0x0,0x1004,0x1004,0x0,0x1004,0x0,0x1004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1004,0x0,0x0,0x0,0x0,0x1004,0x1004,0x1004,0x2,0x0,0x1004,0x0,0x0,0x1004,0x0,0x1004,0x1004,0x0,0x1004,0x1004,0x1004,0x1004,0x0,0x1004,0x0,0x0,0x0,0x0,0x0,0x0,0x1004,0x0,0x4,0x0,0x4,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x4,0x0,0x0,0x0,0x4,0x0,0x0,0x4,0x0,0x1c,0x1c,0x1c,0x0,0xe0,0x1c,0x4,0x1c,0x1c,0xe00,0xe00,0x1c,0x0,0x4,0x4,0xc,0xc,};
   }

  /** Constructor with InputStream. */
  public RubyParser14(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public RubyParser14(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new RubyParser14TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 140; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 140; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public RubyParser14(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new RubyParser14TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 140; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 140; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public RubyParser14(RubyParser14TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 140; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(RubyParser14TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 140; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[109];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 140; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 109; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
