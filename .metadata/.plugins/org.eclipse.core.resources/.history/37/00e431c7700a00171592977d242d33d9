/* Generated By:JavaCC: Do not edit this line. RubyParserReload.java */
import java.io.StringReader;
import java.io.InputStream;
import java.io.Reader;

public class RubyParserReload implements RubyParserReloadConstants {

        private static InputStream input;

        private static int amountOfStatements = 0;

        private static boolean inputFromFile = true;

        private static String file = "src/tests/code3.rb";

        private class Metrics {
                private final static int AMOUNT_OF_METRICS = 23;
                public long metrics[] = new long[AMOUNT_OF_METRICS];
        }

        /*  
	 * A String based constructor for ease of use
	 */
        public RubyParserReload(String s) {
                this((Reader)(new StringReader(s)));
        }

        public static void main(String args[]) {
                try {
                        if (inputFromFile) {
                                System.out.println("Reading from file " + file + " ...");
                                try {
                                        input = new java.io.FileInputStream(file);
                                } catch (java.io.FileNotFoundException e) {
                                        System.out.println("File " + file + " not found.");
                                        return;
                                }
                        } else {
                                System.out.println("Reading from standard input ...");
                                input = System.in;
                        }

                        RubyParserReload parser = new RubyParserReload(input);
                        parser.STRING();
                        System.out.println("Done! Amount of statements = " + amountOfStatements);
                }
                catch(Exception e) {
                        e.printStackTrace();
        }
    }

// Add "Space"?
  static final public void SYMBOLS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case pipe:
      jj_consume_token(pipe);
      break;
    case minus:
      jj_consume_token(minus);
      break;
    case exclamation:
      jj_consume_token(exclamation);
      break;
    case colon:
      jj_consume_token(colon);
      break;
    case dollar:
      jj_consume_token(dollar);
      break;
    case percent:
      jj_consume_token(percent);
      break;
    case amper:
      jj_consume_token(amper);
      break;
    case lparen:
      jj_consume_token(lparen);
      break;
    case rparen:
      jj_consume_token(rparen);
      break;
    case star:
      jj_consume_token(star);
      break;
    case plus:
      jj_consume_token(plus);
      break;
    case comma:
      jj_consume_token(comma);
      break;
    case dot:
      jj_consume_token(dot);
      break;
    case slash:
      jj_consume_token(slash);
      break;
    case number:
      jj_consume_token(number);
      break;
    case less:
      jj_consume_token(less);
      break;
    case equal:
      jj_consume_token(equal);
      break;
    case more:
      jj_consume_token(more);
      break;
    case question:
      jj_consume_token(question);
      break;
    case at:
      jj_consume_token(at);
      break;
    case lsqbracket:
      jj_consume_token(lsqbracket);
      break;
    case backslash:
      jj_consume_token(backslash);
      break;
    case rsqbracket:
      jj_consume_token(rsqbracket);
      break;
    case caret:
      jj_consume_token(caret);
      break;
    case underscore:
      jj_consume_token(underscore);
      break;
    case backapostr:
      jj_consume_token(backapostr);
      break;
    case lbrace:
      jj_consume_token(lbrace);
      break;
    case rbrace:
      jj_consume_token(rbrace);
      break;
    case tilde:
      jj_consume_token(tilde);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void LETTER() throws ParseException {
    jj_consume_token(letter);
  }

  static final public void PROGRAM() throws ParseException {
    COMPSTMT();
    jj_consume_token(0);
  }

  static final public void COMPSTMT() throws ParseException {
    STMT();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      jj_consume_token(T);
      EXPR();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T:
      jj_consume_token(T);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
  }

  static final public void STMT() throws ParseException {
    STMT2();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_if:
      case keyword_while:
      case keyword_unless:
      case keyword_until:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_if:
        jj_consume_token(keyword_if);
        break;
      case keyword_while:
        jj_consume_token(keyword_while);
        break;
      case keyword_unless:
        jj_consume_token(keyword_unless);
        break;
      case keyword_until:
        jj_consume_token(keyword_until);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      EXPR();
    }
  }

  static final public void STMT2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      CALL();
      jj_consume_token(keyword_do);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pipe:
        jj_consume_token(pipe);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case lshift:
        case star:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          BLOCK_VAR();
          break;
        default:
          jj_la1[5] = jj_gen;
          ;
        }
        jj_consume_token(pipe);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      COMPSTMT();
      jj_consume_token(keyword_end);
      break;
    case keyword_undef:
      jj_consume_token(keyword_undef);
      FNAME();
      break;
    case keyword_alias:
      jj_consume_token(keyword_alias);
      FNAME();
      FNAME();
      break;
    case keyword_BEGIN:
    case keyword_END:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_BEGIN:
        jj_consume_token(keyword_BEGIN);
        break;
      case keyword_END:
        jj_consume_token(keyword_END);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(lbrace);
      COMPSTMT();
      jj_consume_token(rbrace);
      break;
      case exclamation:
    case tilde:
    case plus:
    case minus:
    case star:
    case keyword_not:
      EXPR();
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void EXPR() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case star:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      MLHS();
      jj_consume_token(equal);
      MRHS();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
        case keyword_or:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
          jj_consume_token(keyword_and);
          break;
        case keyword_or:
          jj_consume_token(keyword_or);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        EXPR();
      }
      break;
      case keyword_not:
      jj_consume_token(keyword_not);
      EXPR();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
        case keyword_or:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
          jj_consume_token(keyword_and);
          break;
        case keyword_or:
          jj_consume_token(keyword_or);
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        EXPR();
      }
      break;
    case exclamation:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case exclamation:
        jj_consume_token(exclamation);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      COMMAND();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
        case keyword_or:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
          jj_consume_token(keyword_and);
          break;
        case keyword_or:
          jj_consume_token(keyword_or);
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        EXPR();
      }
      break;
    case tilde:
    case plus:
    case minus:
      ARG();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
        case keyword_or:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_7;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_and:
          jj_consume_token(keyword_and);
          break;
        case keyword_or:
          jj_consume_token(keyword_or);
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        EXPR();
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void MLHS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      MLHS_ITEM();
      jj_consume_token(comma);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case lshift:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        MLHS_ITEM();
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case comma:
            ;
            break;
          default:
            jj_la1[25] = jj_gen;
            break label_8;
          }
          jj_consume_token(comma);
          MLHS_ITEM();
        }
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case star:
        jj_consume_token(star);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case lshift:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          LHS();
          break;
        default:
          jj_la1[27] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      LHS();
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void ANYCHARACTER() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
      LETTER();
      break;
    case digit:
      jj_consume_token(digit);
      break;
    case pipe:
    case backslash:
    case backapostr:
    case colon:
    case number:
    case equal:
    case underscore:
    case lbrace:
    case rbrace:
    case at:
    case dollar:
    case lsqbracket:
    case rsqbracket:
    case lparen:
    case rparen:
    case comma:
    case exclamation:
    case question:
    case tilde:
    case less:
    case more:
    case caret:
    case dot:
    case plus:
    case minus:
    case star:
    case slash:
    case percent:
    case amper:
      SYMBOLS();
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void character() throws ParseException {
    LETTER();
  }

  static final public void CALL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      FUNCTION();
      break;
      default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void COMMAND() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
      OPERATION();
      CALL_ARGS();
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      PRIMARY();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      CALL_ARGS();
      break;
      default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void FUNCTION() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      break;
    case lparen:
      jj_consume_token(lparen);
      COMPSTMT();
      jj_consume_token(rparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[38] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lshift:
    case slash:
    case percent:
    case keyword_numeric:
      LITERAL();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[42] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      break;
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
      VARIABLE();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[46] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      break;
    case lbrace:
    case lsqbracket:
    case colon2:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_return:
    case keyword_super:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case lshift:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        PRIMARY();
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      jj_consume_token(colon2);
      IDENTIFIER();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[51] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      break;
      default:
      jj_la1[143] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void FUNCTION2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lbrace:
      jj_consume_token(lbrace);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pipe:
        jj_consume_token(pipe);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case lshift:
        case star:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          BLOCK_VAR();
          break;
        default:
          jj_la1[144] = jj_gen;
          ;
        }
        jj_consume_token(pipe);
        break;
      default:
        jj_la1[145] = jj_gen;
        ;
      }
      COMPSTMT();
      jj_consume_token(rbrace);
      break;
    default:
      jj_la1[146] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case dot:
      jj_consume_token(dot);
      break;
    case colon2:
      jj_consume_token(colon2);
      break;
    default:
      jj_la1[147] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    OPERATION();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lparen:
      jj_consume_token(lparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case star:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        CALL_ARGS();
        break;
      default:
        jj_la1[148] = jj_gen;
        ;
      }
      jj_consume_token(rparen);
      break;
    default:
      jj_la1[149] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lbrace:
    case dot:
    case colon2:
      FUNCTION2();
      break;
    default:
      jj_la1[150] = jj_gen;
      ;
    }
  }

  static final public void ARG() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      LHS();
      jj_consume_token(equal);
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case pipe:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case equal2:
      case equal3:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case exclamationequal:
      case exclamationtilde:
      case equaltilde:
      case tilde:
      case less:
      case lshift:
      case more:
      case lessorequal:
      case moreorequal:
      case lessequalmore:
      case caret:
      case dot2:
      case dot3:
      case plus:
      case minus:
      case star:
      case power:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARG2();
        break;
      default:
        jj_la1[151] = jj_gen;
        ;
      }
      break;
      case plus:
    case minus:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case plus:
        jj_consume_token(plus);
        break;
      case minus:
        jj_consume_token(minus);
        break;
      default:
        jj_la1[153] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case pipe:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case equal2:
      case equal3:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case exclamationequal:
      case exclamationtilde:
      case equaltilde:
      case tilde:
      case less:
      case lshift:
      case more:
      case lessorequal:
      case moreorequal:
      case lessequalmore:
      case caret:
      case dot2:
      case dot3:
      case plus:
      case minus:
      case star:
      case power:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARG2();
        break;
      default:
        jj_la1[154] = jj_gen;
        ;
      }
      break;
    case exclamation:
    case tilde:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case exclamation:
        jj_consume_token(exclamation);
        break;
      case tilde:
        jj_consume_token(tilde);
        break;
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case pipe:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case equal2:
      case equal3:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case exclamationequal:
      case exclamationtilde:
      case equaltilde:
      case tilde:
      case less:
      case lshift:
      case more:
      case lessorequal:
      case moreorequal:
      case lessequalmore:
      case caret:
      case dot2:
      case dot3:
      case plus:
      case minus:
      case star:
      case power:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARG2();
        break;
      default:
        jj_la1[156] = jj_gen;
        ;
      }
      break;
      default:
      jj_la1[159] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void ARG2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case dot2:
    case dot3:
    case plus:
    case minus:
    case star:
    case power:
    case slash:
    case percent:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot2:
        jj_consume_token(dot2);
        break;
      case dot3:
        jj_consume_token(dot3);
        break;
      case plus:
        jj_consume_token(plus);
        break;
      case minus:
        jj_consume_token(minus);
        break;
      case star:
        jj_consume_token(star);
        break;
      case slash:
        jj_consume_token(slash);
        break;
      case percent:
        jj_consume_token(percent);
        break;
      case power:
        jj_consume_token(power);
        break;
      default:
        jj_la1[160] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case pipe:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case equal2:
      case equal3:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case exclamationequal:
      case exclamationtilde:
      case equaltilde:
      case tilde:
      case less:
      case lshift:
      case more:
      case lessorequal:
      case moreorequal:
      case lessequalmore:
      case caret:
      case dot2:
      case dot3:
      case plus:
      case minus:
      case star:
      case power:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARG2();
        break;
      default:
        jj_la1[161] = jj_gen;
        ;
      }
      break;
    case pipe:
    case equal2:
    case equal3:
    case exclamationequal:
    case exclamationtilde:
    case equaltilde:
    case less:
    case more:
    case lessorequal:
    case moreorequal:
    case lessequalmore:
    case caret:
    case amper:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case pipe:
        jj_consume_token(pipe);
        break;
      case caret:
        jj_consume_token(caret);
        break;
      case amper:
        jj_consume_token(amper);
        break;
      case lessequalmore:
        jj_consume_token(lessequalmore);
        break;
      case more:
        jj_consume_token(more);
        break;
      case moreorequal:
        jj_consume_token(moreorequal);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case pipe:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case equal2:
        case equal3:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case exclamationequal:
        case exclamationtilde:
        case equaltilde:
        case tilde:
        case less:
        case lshift:
        case more:
        case lessorequal:
        case moreorequal:
        case lessequalmore:
        case caret:
        case dot2:
        case dot3:
        case plus:
        case minus:
        case star:
        case power:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          ARG2();
          break;
        default:
          jj_la1[162] = jj_gen;
          ;
        }
        break;
      case less:
        jj_consume_token(less);
        break;
      case lessorequal:
        jj_consume_token(lessorequal);
        break;
      case equal2:
        jj_consume_token(equal2);
        break;
      case equal3:
        jj_consume_token(equal3);
        break;
      case exclamationequal:
        jj_consume_token(exclamationequal);
        break;
      case equaltilde:
        jj_consume_token(equaltilde);
        break;
      case exclamationtilde:
        jj_consume_token(exclamationtilde);
        break;
      default:
        jj_la1[163] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case pipe:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case equal2:
      case equal3:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case exclamationequal:
      case exclamationtilde:
      case equaltilde:
      case tilde:
      case less:
      case lshift:
      case more:
      case lessorequal:
      case moreorequal:
      case lessequalmore:
      case caret:
      case dot2:
      case dot3:
      case plus:
      case minus:
      case star:
      case power:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARG2();
        break;
      default:
        jj_la1[164] = jj_gen;
        ;
      }
      break;
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lshift:
        jj_consume_token(lshift);
        break;
      case rshift:
        jj_consume_token(rshift);
        break;
      case and:
        jj_consume_token(and);
        break;
      case or:
        jj_consume_token(or);
        break;
      default:
        jj_la1[165] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case pipe:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case equal2:
      case equal3:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case exclamationequal:
      case exclamationtilde:
      case equaltilde:
      case tilde:
      case less:
      case lshift:
      case more:
      case lessorequal:
      case moreorequal:
      case lessequalmore:
      case caret:
      case dot2:
      case dot3:
      case plus:
      case minus:
      case star:
      case power:
      case slash:
      case percent:
      case amper:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARG2();
        break;
      default:
        jj_la1[166] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[167] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void PRIMARY() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lparen:
      jj_consume_token(lparen);
      COMPSTMT();
      jj_consume_token(rparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[168] = jj_gen;
        ;
      }
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lshift:
    case slash:
    case percent:
    case keyword_numeric:
      LITERAL();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[169] = jj_gen;
        ;
      }
      break;
    case letter:
    case underscore:
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
      VARIABLE();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[170] = jj_gen;
        ;
      }
      break;
    case colon2:
      jj_consume_token(colon2);
      IDENTIFIER();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[171] = jj_gen;
        ;
      }
      break;
    case lsqbracket:
      jj_consume_token(lsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARGS();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          jj_consume_token(comma);
          break;
        default:
          jj_la1[172] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[173] = jj_gen;
        ;
      }
      jj_consume_token(rsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[174] = jj_gen;
        ;
      }
      break;
    case lbrace:
      jj_consume_token(lbrace);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          ARGS();
          break;
          default:
          jj_la1[176] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[177] = jj_gen;
        ;
      }
      jj_consume_token(rbrace);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[178] = jj_gen;
        ;
      }
      break;
    case keyword_yield:
    case keyword_return:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_return:
        jj_consume_token(keyword_return);
        break;
      case keyword_yield:
        jj_consume_token(keyword_yield);
        break;
      default:
        jj_la1[179] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[180] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[181] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[182] = jj_gen;
        ;
      }
      break;
    case keyword_defined:
      jj_consume_token(keyword_defined);
      jj_consume_token(lparen);
      ARG();
      jj_consume_token(rparen);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[183] = jj_gen;
        ;
      }
      break;
      case keyword_if:
      jj_consume_token(keyword_if);
      EXPR();
      THEN();
      COMPSTMT();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_elsif:
          ;
          break;
        default:
          jj_la1[272] = jj_gen;
          break label_12;
        }
        jj_consume_token(keyword_elsif);
        EXPR();
        THEN();
        COMPSTMT();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[273] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[274] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[275] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[276] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[277] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[278] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[279] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[280] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[281] = jj_gen;
        ;
      }
      break;
    case keyword_unless:
      jj_consume_token(keyword_unless);
      EXPR();
      THEN();
      COMPSTMT();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[282] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[283] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[284] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[285] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[286] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[287] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[288] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[289] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[290] = jj_gen;
        ;
      }
      break;
    case keyword_while:
    case keyword_until:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_while:
        jj_consume_token(keyword_while);
        break;
      case keyword_until:
        jj_consume_token(keyword_until);
        break;
      default:
        jj_la1[291] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      EXPR();
      DO();
      COMPSTMT();
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[292] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[293] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[294] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[295] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[296] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[297] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[298] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[299] = jj_gen;
        ;
      }
      break;
    case keyword_case:
      jj_consume_token(keyword_case);
      COMPSTMT();
      jj_consume_token(keyword_when);
      WHEN_ARGS();
      THEN();
      COMPSTMT();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_when:
          ;
          break;
        default:
          jj_la1[300] = jj_gen;
          break label_13;
        }
        jj_consume_token(keyword_when);
        WHEN_ARGS();
        THEN();
        COMPSTMT();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[301] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[302] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[303] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[304] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[305] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[306] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[307] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[308] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[309] = jj_gen;
        ;
      }
      break;
    case keyword_for:
      jj_consume_token(keyword_for);
      BLOCK_VAR();
      jj_consume_token(keyword_in);
      EXPR();
      DO();
      COMPSTMT();
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[310] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[311] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[312] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[313] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[314] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[315] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[316] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[317] = jj_gen;
        ;
      }
      break;
    case keyword_begin:
      jj_consume_token(keyword_begin);
      COMPSTMT();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case keyword_rescue:
          ;
          break;
        default:
          jj_la1[318] = jj_gen;
          break label_14;
        }
        jj_consume_token(keyword_rescue);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case slash:
        case percent:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          ARGS();
          break;
        default:
          jj_la1[319] = jj_gen;
          ;
        }
        DO();
        COMPSTMT();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_else:
        jj_consume_token(keyword_else);
        COMPSTMT();
        break;
      default:
        jj_la1[320] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case keyword_ensure:
        jj_consume_token(keyword_ensure);
        COMPSTMT();
        break;
      default:
        jj_la1[321] = jj_gen;
        ;
      }
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[322] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[323] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[324] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[325] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[326] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[327] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[328] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[329] = jj_gen;
        ;
      }
      break;
    case keyword_class:
      jj_consume_token(keyword_class);
      IDENTIFIER();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case less:
        jj_consume_token(less);
        IDENTIFIER();
        break;
      default:
        jj_la1[330] = jj_gen;
        ;
      }
      COMPSTMT();
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[331] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[332] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[333] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[334] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[335] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[336] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[337] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[338] = jj_gen;
        ;
      }
      break;
    case keyword_module:
      jj_consume_token(keyword_module);
      IDENTIFIER();
      COMPSTMT();
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[339] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[340] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[341] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[342] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[343] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[344] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[345] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[346] = jj_gen;
        ;
      }
      break;
    case keyword_def:
      jj_consume_token(keyword_def);
      FNAME();
      ARGDECL();
      COMPSTMT();
      jj_consume_token(keyword_end);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case dot:
        jj_consume_token(dot);
        break;
      case colon2:
        jj_consume_token(colon2);
        break;
      default:
        jj_la1[347] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      OPERATION();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[348] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[349] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[350] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[351] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[352] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[353] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[354] = jj_gen;
        ;
      }
      break;
      case keyword_super:
      jj_consume_token(keyword_super);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lparen:
        jj_consume_token(lparen);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case quote:
        case apostr:
        case backapostr:
        case colon:
        case underscore:
        case lbrace:
        case at:
        case dollar:
        case lsqbracket:
        case lparen:
        case exclamation:
        case tilde:
        case lshift:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
        case colon2:
        case keyword_self:
        case keyword_defined:
        case keyword_begin:
        case keyword_case:
        case keyword_for:
        case keyword_class:
        case keyword_numeric:
        case keyword_if:
        case keyword_while:
        case keyword_module:
        case keyword_def:
        case keyword_unless:
        case keyword_until:
        case keyword_yield:
        case keyword_nil:
        case keyword_return:
        case keyword_super:
          CALL_ARGS();
          break;
        default:
          jj_la1[364] = jj_gen;
          ;
        }
        jj_consume_token(rparen);
        break;
      default:
        jj_la1[365] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
      case dot:
      case colon2:
        FUNCTION2();
        break;
      default:
        jj_la1[366] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lbrace:
        jj_consume_token(lbrace);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case pipe:
          jj_consume_token(pipe);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case letter:
          case quote:
          case apostr:
          case backapostr:
          case colon:
          case underscore:
          case lbrace:
          case at:
          case dollar:
          case lsqbracket:
          case lparen:
          case lshift:
          case star:
          case slash:
          case percent:
          case colon2:
          case keyword_self:
          case keyword_defined:
          case keyword_begin:
          case keyword_case:
          case keyword_for:
          case keyword_class:
          case keyword_numeric:
          case keyword_if:
          case keyword_while:
          case keyword_module:
          case keyword_def:
          case keyword_unless:
          case keyword_until:
          case keyword_yield:
          case keyword_nil:
          case keyword_return:
          case keyword_super:
            BLOCK_VAR();
            break;
          default:
            jj_la1[367] = jj_gen;
            ;
          }
          jj_consume_token(pipe);
          break;
        default:
          jj_la1[368] = jj_gen;
          ;
        }
        COMPSTMT();
        jj_consume_token(rbrace);
        break;
      default:
        jj_la1[369] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[370] = jj_gen;
        ;
      }
      break;
      default:
      jj_la1[393] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void PRIMARY2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case colon2:
      jj_consume_token(colon2);
      IDENTIFIER();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[394] = jj_gen;
        ;
      }
      break;
    case lsqbracket:
      jj_consume_token(lsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARGS();
        break;
      default:
        jj_la1[395] = jj_gen;
        ;
      }
      jj_consume_token(rsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case lsqbracket:
      case colon2:
        PRIMARY2();
        break;
      default:
        jj_la1[396] = jj_gen;
        ;
      }
      break;
      default:
      jj_la1[414] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void WHEN_ARGS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case plus:
    case minus:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      ARGS();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(star);
        ARG();
        break;
      default:
        jj_la1[415] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      ARG();
      break;
    default:
      jj_la1[416] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void THEN() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T:
      jj_consume_token(T);
      break;
    case keyword_then:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T:
        jj_consume_token(T);
        break;
      default:
        jj_la1[417] = jj_gen;
        ;
      }
      jj_consume_token(keyword_then);
      break;
    default:
      jj_la1[418] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void DO() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T:
      jj_consume_token(T);
      break;
    case keyword_do:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T:
        jj_consume_token(T);
        break;
      default:
        jj_la1[419] = jj_gen;
        ;
      }
      jj_consume_token(keyword_do);
      break;
    default:
      jj_la1[420] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void BLOCK_VAR() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      LHS();
      break;
    case star:
      MLHS();
      break;
    default:
      jj_la1[421] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void MLHS_ITEM() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      LHS();
      break;
      default:
      jj_la1[422] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void LHS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
      VARIABLE();
      break;
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case lbrace:
    case lsqbracket:
    case lparen:
    case lshift:
    case slash:
    case percent:
    case colon2:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_return:
    case keyword_super:
      PRIMARY();
      jj_consume_token(lsqbracket);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case quote:
      case apostr:
      case backapostr:
      case colon:
      case underscore:
      case lbrace:
      case at:
      case dollar:
      case lsqbracket:
      case lparen:
      case exclamation:
      case tilde:
      case lshift:
      case plus:
      case minus:
      case slash:
      case percent:
      case colon2:
      case keyword_self:
      case keyword_defined:
      case keyword_begin:
      case keyword_case:
      case keyword_for:
      case keyword_class:
      case keyword_numeric:
      case keyword_if:
      case keyword_while:
      case keyword_module:
      case keyword_def:
      case keyword_unless:
      case keyword_until:
      case keyword_yield:
      case keyword_nil:
      case keyword_return:
      case keyword_super:
        ARGS();
        break;
      default:
        jj_la1[423] = jj_gen;
        ;
      }
      jj_consume_token(rsqbracket);
      break;
      default:
      jj_la1[424] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void MRHS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case plus:
    case minus:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      ARGS();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(star);
        ARG();
        break;
      default:
        jj_la1[425] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      ARG();
      break;
    default:
      jj_la1[426] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void CALL_ARGS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case quote:
    case apostr:
    case backapostr:
    case colon:
    case underscore:
    case lbrace:
    case at:
    case dollar:
    case lsqbracket:
    case lparen:
    case exclamation:
    case tilde:
    case lshift:
    case plus:
    case minus:
    case slash:
    case percent:
    case colon2:
    case keyword_self:
    case keyword_defined:
    case keyword_begin:
    case keyword_case:
    case keyword_for:
    case keyword_class:
    case keyword_numeric:
    case keyword_if:
    case keyword_while:
    case keyword_module:
    case keyword_def:
    case keyword_unless:
    case keyword_until:
    case keyword_yield:
    case keyword_nil:
    case keyword_return:
    case keyword_super:
      ARGS();
      break;
      case star:
      jj_consume_token(star);
      ARG();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(amper);
        ARG();
        break;
      default:
        jj_la1[432] = jj_gen;
        ;
      }
      break;
    case amper:
      jj_consume_token(amper);
      ARG();
      break;
      default:
      jj_la1[433] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void ARGS() throws ParseException {
    ARG();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        ;
        break;
      default:
        jj_la1[434] = jj_gen;
        break label_18;
      }
      jj_consume_token(comma);
      ARG();
    }
  }

  static final public void ARGDECL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case lparen:
      jj_consume_token(lparen);
      ARGLIST();
      jj_consume_token(rparen);
      break;
    case T:
    case letter:
    case underscore:
    case star:
    case amper:
      ARGLIST();
      jj_consume_token(T);
      break;
    default:
      jj_la1[435] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void ARGLIST() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
      IDENTIFIER();
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case comma:
          ;
          break;
        default:
          jj_la1[436] = jj_gen;
          break label_19;
        }
        jj_consume_token(comma);
        IDENTIFIER();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(star);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case underscore:
          IDENTIFIER();
          break;
        default:
          jj_la1[437] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[438] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(amper);
        IDENTIFIER();
        break;
      default:
        jj_la1[439] = jj_gen;
        ;
      }
      break;
    case star:
      jj_consume_token(star);
      IDENTIFIER();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        jj_consume_token(comma);
        jj_consume_token(amper);
        IDENTIFIER();
        break;
      default:
        jj_la1[440] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[442] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case amper:
        jj_consume_token(amper);
        IDENTIFIER();
        break;
      default:
        jj_la1[441] = jj_gen;
        ;
      }
    }
  }

  static final public void SINGLETON() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
    case at:
    case dollar:
    case keyword_self:
    case keyword_nil:
      VARIABLE();
      break;
    case lparen:
      jj_consume_token(lparen);
      EXPR();
      jj_consume_token(rparen);
      break;
    default:
      jj_la1[443] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void ASSOCS() throws ParseException {
    ASSOC();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case comma:
        ;
        break;
      default:
        jj_la1[444] = jj_gen;
        break label_20;
      }
      jj_consume_token(comma);
      ASSOC();
    }
  }

  static final public void ASSOC() throws ParseException {
    ARG();
    jj_consume_token(equalmore);
    ARG();
  }

  static final public void VARIABLE() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
    case at:
    case dollar:
      VARNAME();
      break;
    case keyword_nil:
      jj_consume_token(keyword_nil);
      break;
    case keyword_self:
      jj_consume_token(keyword_self);
      break;
    default:
      jj_la1[445] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void LITERAL() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case keyword_numeric:
      jj_consume_token(keyword_numeric);
      break;
    case colon:
      SYMBOL();
      break;
    case quote:
    case apostr:
    case backapostr:
      STRING();
      break;
    case percent:
      STRING2();
      break;
    case lshift:
      HERE_DOC();
      break;
    case slash:
      REGEXP();
      break;
    default:
      jj_la1[446] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void OP_ASGN() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case plusequal:
      jj_consume_token(plusequal);
      break;
    case minusequal:
      jj_consume_token(minusequal);
      break;
    case starequal:
      jj_consume_token(starequal);
      break;
    case slashequal:
      jj_consume_token(slashequal);
      break;
    case percentequal:
      jj_consume_token(percentequal);
      break;
    case powerequal:
      jj_consume_token(powerequal);
      break;
    case amperequal:
      jj_consume_token(amperequal);
      break;
    case pipeequal:
      jj_consume_token(pipeequal);
      break;
    case caretequal:
      jj_consume_token(caretequal);
      break;
    case lshiftequal:
      jj_consume_token(lshiftequal);
      break;
    case rshiftequal:
      jj_consume_token(rshiftequal);
      break;
    case andequal:
      jj_consume_token(andequal);
      break;
    case orequal:
      jj_consume_token(orequal);
      break;
    default:
      jj_la1[447] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void SYMBOL() throws ParseException {
    jj_consume_token(colon);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case pipe:
    case underscore:
    case equal2:
    case equal3:
    case plusat:
    case minusat:
    case sqbrackets:
    case sqbracketsequal:
    case equaltilde:
    case tilde:
    case less:
    case lshift:
    case more:
    case rshift:
    case lessorequal:
    case moreorequal:
    case lessequalmore:
    case caret:
    case dot2:
    case plus:
    case minus:
    case star:
    case power:
    case slash:
    case percent:
    case amper:
      FNAME();
      break;
    case at:
    case dollar:
      VARNAME();
      break;
    default:
      jj_la1[448] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void FNAME() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
      IDENTIFIER();
      break;
    case dot2:
      jj_consume_token(dot2);
      break;
    case pipe:
      jj_consume_token(pipe);
      break;
    case caret:
      jj_consume_token(caret);
      break;
    case amper:
      jj_consume_token(amper);
      break;
    case lessequalmore:
      jj_consume_token(lessequalmore);
      break;
    case equal2:
      jj_consume_token(equal2);
      break;
    case equal3:
      jj_consume_token(equal3);
      break;
    case equaltilde:
      jj_consume_token(equaltilde);
      break;
    case more:
      jj_consume_token(more);
      break;
    case moreorequal:
      jj_consume_token(moreorequal);
      break;
    case less:
      jj_consume_token(less);
      break;
    case lessorequal:
      jj_consume_token(lessorequal);
      break;
    case plus:
      jj_consume_token(plus);
      break;
    case minus:
      jj_consume_token(minus);
      break;
    case star:
      jj_consume_token(star);
      break;
    case slash:
      jj_consume_token(slash);
      break;
    case percent:
      jj_consume_token(percent);
      break;
    case power:
      jj_consume_token(power);
      break;
    case lshift:
      jj_consume_token(lshift);
      break;
    case rshift:
      jj_consume_token(rshift);
      break;
    case tilde:
      jj_consume_token(tilde);
      break;
    case plusat:
      jj_consume_token(plusat);
      break;
    case minusat:
      jj_consume_token(minusat);
      break;
    case sqbrackets:
      jj_consume_token(sqbrackets);
      break;
    case sqbracketsequal:
      jj_consume_token(sqbracketsequal);
      break;
    default:
      jj_la1[449] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void OPERATION() throws ParseException {
    IDENTIFIER();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case exclamation:
    case question:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case exclamation:
        jj_consume_token(exclamation);
        break;
      case question:
        jj_consume_token(question);
        break;
      default:
        jj_la1[450] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[451] = jj_gen;
      ;
    }
  }

  static final public void VARNAME() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case dollar:
      GLOBAL();
      break;
    case letter:
    case underscore:
    case at:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case at:
        jj_consume_token(at);
        break;
      default:
        jj_la1[452] = jj_gen;
        ;
      }
      IDENTIFIER();
      break;
    default:
      jj_la1[453] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void GLOBAL() throws ParseException {
    jj_consume_token(dollar);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
      IDENTIFIER();
      break;
    case dollar:
      jj_consume_token(dollar);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case minus:
        jj_consume_token(minus);
        break;
      default:
        jj_la1[454] = jj_gen;
        ;
      }
      ANYCHARACTER();
      break;
    default:
      jj_la1[455] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void STRING() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case quote:
      jj_consume_token(quote);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case pipe:
        case backslash:
        case backapostr:
        case colon:
        case number:
        case equal:
        case underscore:
        case lbrace:
        case rbrace:
        case at:
        case dollar:
        case lsqbracket:
        case rsqbracket:
        case lparen:
        case rparen:
        case comma:
        case exclamation:
        case question:
        case tilde:
        case less:
        case more:
        case caret:
        case dot:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
          ;
          break;
        default:
          jj_la1[456] = jj_gen;
          break label_21;
        }
        ANYCHARACTER();
      }
      jj_consume_token(quote);
      break;
    case apostr:
      jj_consume_token(apostr);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case pipe:
        case backslash:
        case backapostr:
        case colon:
        case number:
        case equal:
        case underscore:
        case lbrace:
        case rbrace:
        case at:
        case dollar:
        case lsqbracket:
        case rsqbracket:
        case lparen:
        case rparen:
        case comma:
        case exclamation:
        case question:
        case tilde:
        case less:
        case more:
        case caret:
        case dot:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
          ;
          break;
        default:
          jj_la1[457] = jj_gen;
          break label_22;
        }
        ANYCHARACTER();
      }
      jj_consume_token(apostr);
      break;
    case backapostr:
      jj_consume_token(backapostr);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case pipe:
        case backslash:
        case backapostr:
        case colon:
        case number:
        case equal:
        case underscore:
        case lbrace:
        case rbrace:
        case at:
        case dollar:
        case lsqbracket:
        case rsqbracket:
        case lparen:
        case rparen:
        case comma:
        case exclamation:
        case question:
        case tilde:
        case less:
        case more:
        case caret:
        case dot:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
          ;
          break;
        default:
          jj_la1[458] = jj_gen;
          break label_23;
        }
        ANYCHARACTER();
      }
      jj_consume_token(backapostr);
      break;
    default:
      jj_la1[459] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void STRING2() throws ParseException {
    jj_consume_token(percent);
    LETTER();
    character();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case digit:
      case pipe:
      case backslash:
      case backapostr:
      case colon:
      case number:
      case equal:
      case underscore:
      case lbrace:
      case rbrace:
      case at:
      case dollar:
      case lsqbracket:
      case rsqbracket:
      case lparen:
      case rparen:
      case comma:
      case exclamation:
      case question:
      case tilde:
      case less:
      case more:
      case caret:
      case dot:
      case plus:
      case minus:
      case star:
      case slash:
      case percent:
      case amper:
        ;
        break;
      default:
        jj_la1[460] = jj_gen;
        break label_24;
      }
      ANYCHARACTER();
    }
    character();
  }

  static final public void HERE_DOC() throws ParseException {
    jj_consume_token(lshift);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case letter:
    case underscore:
      IDENTIFIER();
      break;
    case quote:
    case apostr:
    case backapostr:
      STRING();
      break;
    default:
      jj_la1[461] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case digit:
      case pipe:
      case backslash:
      case backapostr:
      case colon:
      case number:
      case equal:
      case underscore:
      case lbrace:
      case rbrace:
      case at:
      case dollar:
      case lsqbracket:
      case rsqbracket:
      case lparen:
      case rparen:
      case comma:
      case exclamation:
      case question:
      case tilde:
      case less:
      case more:
      case caret:
      case dot:
      case plus:
      case minus:
      case star:
      case slash:
      case percent:
      case amper:
        ;
        break;
      default:
        jj_la1[462] = jj_gen;
        break label_25;
      }
      ANYCHARACTER();
    }
    IDENTIFIER();
  }

  static final public void REGEXP() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case slash:
      jj_consume_token(slash);
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case pipe:
        case backslash:
        case backapostr:
        case colon:
        case number:
        case equal:
        case underscore:
        case lbrace:
        case rbrace:
        case at:
        case dollar:
        case lsqbracket:
        case rsqbracket:
        case lparen:
        case rparen:
        case comma:
        case exclamation:
        case question:
        case tilde:
        case less:
        case more:
        case caret:
        case dot:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
          ;
          break;
        default:
          jj_la1[463] = jj_gen;
          break label_26;
        }
        ANYCHARACTER();
      }
      jj_consume_token(slash);
      break;
    case percent:
      jj_consume_token(percent);
      LETTER();
      character();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case letter:
        case digit:
        case pipe:
        case backslash:
        case backapostr:
        case colon:
        case number:
        case equal:
        case underscore:
        case lbrace:
        case rbrace:
        case at:
        case dollar:
        case lsqbracket:
        case rsqbracket:
        case lparen:
        case rparen:
        case comma:
        case exclamation:
        case question:
        case tilde:
        case less:
        case more:
        case caret:
        case dot:
        case plus:
        case minus:
        case star:
        case slash:
        case percent:
        case amper:
          ;
          break;
        default:
          jj_la1[464] = jj_gen;
          break label_27;
        }
        ANYCHARACTER();
      }
      character();
      break;
    default:
      jj_la1[465] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void IDENTIFIER() throws ParseException {
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
        LETTER();
        break;
      case underscore:
        jj_consume_token(underscore);
        break;
      default:
        jj_la1[466] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case underscore:
        ;
        break;
      default:
        jj_la1[467] = jj_gen;
        break label_28;
      }
    }
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
      case digit:
      case underscore:
        ;
        break;
      default:
        jj_la1[468] = jj_gen;
        break label_29;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case letter:
        LETTER();
        break;
      case underscore:
        jj_consume_token(underscore);
        break;
      case digit:
        jj_consume_token(digit);
        break;
      default:
        jj_la1[469] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public RubyParserReloadTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[470];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xe0007d80,0x8,0x8,0x0,0x0,0xa0004e30,0x80,0x0,0xa0004e30,0x80,0x0,0xa0004e30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0004e30,0x0,0xa0004e30,0xa0004e30,0x0,0xa0004e30,0xe0007dd0,0xa0004e30,0x0,0xa0004e30,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0xa0004e30,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x0,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x0,0x20000000,0xa0004e30,0xa0004e30,0x80,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0xb8004eb0,0xb8004eb0,0x0,0xb8004eb0,0x0,0xb8004eb0,0xb8004eb0,0xb8004eb0,0xa0004e30,0x0,0xb8004eb0,0xb8004eb0,0x18000080,0xb8004eb0,0x0,0xb8004eb0,0xb8004eb0,0x0,0x0,0x0,0x0,0x0,0xa0004e30,0x0,0x0,0xa0004e30,0xa0004e30,0x0,0x0,0xa0004e30,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0xa0004e30,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0xa0004e30,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0xa0004e30,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0004e30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0004e30,0x0,0xa0004e30,0x0,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0xa0004e30,0x0,0xa0004e30,0x0,0x20000000,0xa0004e30,0x80,0x20000000,0x0,0x0,0x0,0xa0004e30,0x8,0x8,0x8,0x8,0xa0004e30,0xa0004e30,0xa0004e30,0xa0004e30,0x0,0xa0004e30,0x0,0x0,0x0,0x0,0x0,0x0,0xa0004e30,0x0,0x4018,0x0,0x4010,0x0,0x0,0x0,0x0,0x4010,0x80004010,0x0,0x80004010,0xe20,0x7ff8000,0x98004090,0x18004090,0x0,0x0,0x80000000,0x80004010,0x0,0x4010,0xe0007dd0,0xe0007dd0,0xe0007dd0,0x620,0xe0007dd0,0x4630,0xe0007dd0,0xe0007dd0,0xe0007dd0,0x0,0x4010,0x4010,0x4050,0x4050,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xe6058fc9,0x0,0x0,0x0,0x0,0x80020089,0x0,0x0,0x80020089,0x0,0x0,0xe0028489,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0xe0028489,0x200,0x20089,0x20089,0x80000000,0x80020089,0xe6058fc9,0x20089,0x4000000,0x20089,0xe0028489,0x80,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x20089,0x4000000,0xe0028489,0x80,0x4000000,0x60028489,0x4000000,0xe0028489,0x80,0x4000000,0x200,0x60028489,0x4000000,0xe0028489,0x80,0x4000000,0x200,0x60028489,0x60028489,0x4000000,0xe0028489,0x80,0x4000000,0xe0028489,0x80,0x4000000,0xe0028489,0x80,0x4000000,0xe0028489,0x80,0x4000000,0xe0028489,0x80,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x0,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x0,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x0,0x60028489,0x0,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x10000,0x4000000,0xe0028489,0x80,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0xe0028489,0x80,0x4000000,0x20089,0x80020089,0x0,0x0,0x4000000,0xe0028489,0x80,0x4000000,0xfab7f489,0xfab7f489,0x60000000,0xfab7f489,0x8400,0xfab7f489,0xfab7f489,0xfab7f489,0x60028489,0xf8000000,0xfab7f489,0xfab7f489,0x2b57000,0xfab7f489,0xa0000,0xfab7f489,0xfab7f489,0x8,0x8,0x8,0x8,0x200,0x60028489,0x8,0x200,0x60028489,0x60028489,0x8,0x0,0xe0028489,0x80,0x8,0x8,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x200,0x60028489,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x200,0x60028489,0x60028489,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0xe0028489,0x80,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0xe0028489,0x80,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x0,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x0,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x0,0x60028489,0x0,0x0,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x10000,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x4000000,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x0,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x0,0x8,0x8,0x0,0x60028489,0x0,0x0,0x8,0x10000,0x8,0x8,0x8,0x4000000,0x8,0x20089,0x8,0x60028489,0x8,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x60028489,0x4000000,0xe0028489,0x80,0x4000000,0x80020089,0x0,0x0,0x8,0x8,0x200,0xe0028489,0x0,0x0,0x0,0x0,0x80020089,0x20089,0x60028489,0x20089,0x200,0xe0028489,0x200,0x200,0x200,0x200,0x200,0x200,0xe0028489,0x200,0x80000080,0x200,0x0,0x200,0x200,0x200,0x0,0x80000000,0x81,0x200,0x1,0x20000,0x400000,0xeabfc037,0xeabfc036,0xc00,0xc00,0x0,0x1,0x40000000,0x1,0xe6058fc9,0xe6058fc9,0xe6058fc9,0x0,0xe6058fc9,0x0,0xe6058fc9,0xe6058fc9,0xe6058fc9,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xe,0x0,0x0,0x89000000,0x89000000,0xb902f946,0x0,0xc0000,0xb902f946,0x0,0x80,0xb95ef946,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb902f946,0x0,0xb902f946,0xb902f946,0x0,0xb902f946,0xe,0xb902f946,0x40,0xb902f946,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x40,0xb902f94e,0x0,0x40,0x0,0xb902f946,0x40,0xb902f94e,0x0,0x40,0x0,0xb902f946,0xb902f946,0x40,0xb902f94e,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0x4000000,0x800000,0x40,0xb902f94e,0x0,0x40,0x800000,0x40,0xb902f94e,0x0,0x40,0x8000000,0x40,0xb902f94e,0x0,0x40,0x40000000,0x800000,0x40,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0x200000,0xb902f946,0x800000,0x400,0x40,0xb902f94e,0x0,0x40,0x0,0x40,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f946,0xb902f946,0x0,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f94f,0xb902f94f,0x0,0xb902f94f,0x0,0xb902f94f,0xb902f94f,0xb902f94f,0xb902f946,0x7,0xb902f94f,0xb902f94f,0x8,0xb902f94f,0x30,0xb902f94f,0xb902f94f,0x40,0x40,0x40,0x40,0x0,0xb902f946,0x40,0x0,0xb902f946,0xb902f946,0x40,0x0,0xb902f94e,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x0,0xb902f946,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x0,0xb902f946,0xb902f946,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x4000000,0x800000,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x800000,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x8000000,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40000000,0x800000,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x200000,0xb902f946,0x800000,0x400,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x4000000,0x800000,0x40,0x800000,0x40,0x8000000,0x40,0x40000000,0x800000,0x40,0x40,0x200000,0xb902f946,0x800000,0x400,0x40,0x0,0x40,0x40,0x40,0x40,0x40,0xb902f946,0x40,0xb902f946,0x40,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0xb902f946,0x40,0xb902f94e,0x0,0x40,0xb902f946,0x0,0x0,0x40,0x40,0x0,0xb902f946,0x0,0x200,0x0,0x80,0xb902f946,0xb902f946,0xb902f946,0xb902f946,0x0,0xb902f946,0x0,0x0,0x0,0x0,0x0,0x0,0xb902f94e,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x100,0x0,0x100,0x20006,0x0,0xf,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0xe,0xe,0x0,0xe,0x0,0xe,0xe,0xe,0x6,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x1,0x1,0xa7,0x0,0x0,0xa7,0x0,0x0,0xe7,0x18,0x18,0x22,0x18,0x18,0x18,0x18,0x0,0x18,0x18,0x18,0x18,0xe7,0x0,0xa7,0xa7,0x0,0xa7,0x0,0xa7,0x0,0xa7,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0xa7,0x0,0x0,0xa7,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0xa7,0x0,0x0,0x0,0xa7,0xa7,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x1,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0xa7,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0xa7,0x0,0xa7,0x0,0xa7,0xa7,0xa7,0xa7,0x0,0xa7,0xa7,0x0,0xa7,0x0,0xa7,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0xa7,0x0,0x22,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0xa7,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x1,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0xa7,0x0,0xa7,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0xa7,0xa7,0xa7,0xa7,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public RubyParserReload(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public RubyParserReload(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new RubyParserReloadTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 470; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 470; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public RubyParserReload(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new RubyParserReloadTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 470; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 470; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public RubyParserReload(RubyParserReloadTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 470; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(RubyParserReloadTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 470; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[104];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 470; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 104; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
